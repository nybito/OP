1. Определение операционной системы. Системное и прикладное программное обеспечение
Операционная система (ОС) — это комплекс программ, обеспечивающий управление аппаратными ресурсами компьютера, выполнение прикладных программ и взаимодействие пользователя с вычислительной системой.

Системное программное обеспечение (ПО) — это программы, обеспечивающие работу компьютера и взаимодействие между аппаратурой и прикладными программами. К нему относятся:

Операционные системы

Драйверы устройств

Утилиты (антивирусы, архиваторы, дефрагментаторы)

Системы программирования (компиляторы, интерпретаторы)

Прикладное программное обеспечение — программы, предназначенные для выполнения конкретных задач пользователя:

Офисные приложения (Word, Excel)

Графические редакторы (Photoshop, GIMP)

Браузеры (Chrome, Firefox)

Игры

2. Функции ОС
Основные функции операционной системы:

Управление процессами — создание, планирование, синхронизация и завершение процессов.

Управление памятью — распределение оперативной памяти между процессами, виртуальная память.

Управление файловой системой — работа с файлами и каталогами.

Управление устройствами ввода-вывода — взаимодействие с периферийными устройствами через драйверы.

Обеспечение безопасности — разграничение прав доступа, защита данных.

Пользовательский интерфейс — командная строка, графический интерфейс (GUI).

Сетевые функции — поддержка сетевых протоколов, управление сетевыми ресурсами.

3. Классификация ОС. Однозадачные и многозадачные ОС
Однозадачные ОС — выполняют только одну задачу в один момент времени (например, MS-DOS).
Многозадачные ОС — позволяют выполнять несколько задач одновременно (Windows, Linux, macOS).

Вытесняющая многозадачность — ОС сама распределяет процессорное время между задачами.

Невытесняющая многозадачность — процесс сам решает, когда отдать управление (редко используется).

4. Классификация ОС. Микроядерные и макроядерные ОС
Макроядерные (монолитные) ОС — ядро содержит большинство функций (драйверы, файловые системы, сетевые модули). Примеры: Linux, Windows 9x.
Микроядерные ОС — ядро минимально, основные функции вынесены в пользовательское пространство (более надежно). Примеры: QNX, MINIX, современные версии Windows (гибридное ядро).

5. Классификация ОС. Специализированные операционные системы
Предназначены для конкретных задач:

Встроенные ОС (Embedded OS) — для микроконтроллеров (FreeRTOS, VxWorks).

ОС реального времени (RTOS) — жесткие временные ограничения (QNX, RTLinux).

Сетевые ОС — для серверов (Windows Server, Linux).

Мобильные ОС — Android, iOS.

6. Классификация ОС. Операционные системы общего назначения
Предназначены для широкого круга задач:

Windows (10, 11)

Linux (Ubuntu, Fedora)

macOS

7. Классификация ОС. Системы с асимметричной процессорной обработкой
Используется в многопроцессорных системах:

Асимметричная многопроцессорность (ASMP) — каждый процессор закреплен за конкретной задачей (например, один процессор обрабатывает ввод-вывод, другой — вычисления).

8. Классификация ОС. Системы с симметричной процессорной обработкой
Симметричная многопроцессорность (SMP) — все процессоры равноправны, задачи распределяются динамически (современные ОС: Windows, Linux).

9. Процессы. Граф существования процесса
Процесс — программа в состоянии выполнения.
Граф существования процесса показывает его жизненный цикл:

Создание (загрузка в память).

Готовность (ожидание процессора).

Выполнение (активная работа).

Ожидание (например, ввода-вывода).

Завершение (освобождение ресурсов).

10. Процессы. Классификация процессов
По типу выполнения:

Интерактивные (взаимодействуют с пользователем).

Фоновые (демоны, службы).

По приоритету:

Высокоприоритетные (критичные для системы).

Низкоприоритетные (фоновые задачи).

По зависимости от других процессов:

Родительские (создают дочерние).

Дочерние (зависят от родительских).

11) Процессы. Программные потоки
Процесс — это экземпляр выполняющейся программы, включающий:

Код программы.

Данные (переменные, буферы).

Регистры процессора.

Стек вызовов.

Состояние выполнения (выполняется, ожидает и т. д.).

Поток (thread) — это наименьшая единица выполнения внутри процесса.

Процесс может содержать несколько потоков.

Потоки разделяют ресурсы процесса (память, файлы), но имеют собственные:

Счетчик команд.

Регистры.

Стек.

Потоки позволяют параллельно выполнять задачи внутри одного процесса.

12) Управление ресурсами. Состояние процесса
Управление ресурсами — распределение CPU, памяти, устройств ввода-вывода между процессами.

Состояния процесса:

Новый (New) – создан, но не запущен.

Готовый (Ready) – ожидает выделения CPU.

Выполняющийся (Running) – выполняется на CPU.

Ожидающий (Waiting/Blocked) – ждет ресурс (I/O, семафор и т. д.).

Завершенный (Terminated) – выполнение завершено.

Переходы между состояниями управляются диспетчером процессов (scheduler) и механизмами прерываний.

13) Сохранение состояния процесса
При переключении процессов ОС сохраняет:

Регистры процессора (PC, SP, статус).

Таблицы памяти (адресное пространство).

Открытые файлы и дескрипторы.

Состояние I/O.

Это называется контекст процесса. Переключение (context switch) требует времени, но необходимо для мультипрограммирования.

14) Потоки. Средства синхронизации потоков
Потоки внутри одного процесса разделяют память, что требует синхронизации:

Мьютексы (mutex) – блокируют доступ к ресурсу.

Семафоры (semaphore) – счетчик доступа.

Критические секции – участки кода, выполняемые атомарно.

Условные переменные (condition variables) – ожидание события.

Барьеры (barriers) – синхронизация группы потоков.

Без синхронизации возможны гонки данных (race conditions) и дедлоки (deadlocks).

15) Диспетчеризация процессора. Основная цель диспетчеризации процессора
Диспетчеризация (scheduling) – выбор следующего процесса для выполнения на CPU.

Основные цели:

Справедливость – равное распределение CPU.

Эффективность – минимизация простоев CPU.

Отзывчивость – быстрая реакция на интерактивные задачи.

Пропускная способность – максимум завершенных процессов в единицу времени.

16) Планировщик. Разновидности стратегий, с точки зрения прерывания или избежания прерывания процессов
Типы стратегий планирования:

Невытесняющие (Non-preemptive) – процесс удерживает CPU, пока не завершится или не перейдет в ожидание.

Примеры: FCFS, SJF (невытесняющий вариант).

Вытесняющие (Preemptive) – ОС может прервать процесс и передать CPU другому.

Примеры: Round Robin, SRTF (вытесняющий SJF).

17) Планировщик. Стратегия без прерывания процессов. Диаграмма Ганта
Пример (FCFS – First Come, First Served):
Процессы: P1 (время 5), P2 (время 3), P3 (время 2).

Диаграмма Ганта:

text
| P1 | P2 | P3 |
0   5   8   10
P1 выполняется полностью, затем P2, затем P3.

Недостаток: Долгие процессы задерживают короткие.

18) Планировщик. Стратегия с прерыванием процессов. Диаграмма Ганта
Пример (Round Robin, квант времени = 2):
Процессы: P1 (5), P2 (3), P3 (2).

Диаграмма Ганта:

text
| P1 | P2 | P3 | P1 | P2 | P1 |
0   2   4   6   7   9   11
Каждый процесс получает квант времени, затем вытесняется.

19) Планировщик. Стратегии FCFS и каковы ее недостатки
FCFS (First Come, First Served) – процессы выполняются в порядке поступления.

Недостатки:

Голодание коротких процессов из-за длинных.

Высокий средний время ожидания, если первым идет долгий процесс.

Не подходит для интерактивных систем.

20) Планировщик. Стратегии SJF (и SRTF) и оптимальность по какому критерию она обеспечивает
SJF (Shortest Job First) – выполняется процесс с наименьшим временем выполнения.

Невытесняющий: процесс выполняется до конца.

Оптимальность: минимизирует среднее время ожидания.

SRTF (Shortest Remaining Time First) – вытесняющий вариант SJF.

Если появляется процесс с меньшим оставшимся временем, текущий прерывается.

Оптимальность: минимизирует среднее время ожидания в вытесняющих системах.

Пример SJF:
Процессы: P1 (6), P2 (3), P3 (4).
Порядок: P2 → P3 → P1.

Пример SRTF:
Если P1 начал выполняться, но появился P2 (3), то P1 прерывается.

21. Планировщик. Диспетчер. Диспетчеризация по приоритетам
Планировщик (Scheduler) – компонент ОС, который решает, какой процесс получит доступ к CPU.
Диспетчер (Dispatcher) – модуль, который передает управление CPU выбранному процессу, выполняя переключение контекста.

Диспетчеризация по приоритетам – стратегия, где каждому процессу назначается приоритет. Процессы с более высоким приоритетом выполняются первыми.

Статические приоритеты – назначаются при создании процесса и не меняются.

Динамические приоритеты – могут изменяться во время выполнения (например, в зависимости от времени ожидания).

Проблема: низкоприоритетные процессы могут долго не получать CPU (голодание).

22. Проблема голодания процессов и ее решение в ОС
Голодание (Starvation) – ситуация, когда низкоприоритетные процессы бесконечно откладываются из-за высокоприоритетных.

Решения:

Старение (Aging) – постепенное повышение приоритета процессов, долго ожидающих CPU.

Квотирование – резервирование CPU для низкоприоритетных процессов.

Fair-Share Scheduling – гарантированное выделение ресурсов группам процессов.

23. Стратегии RR, оптимальность по какому критерию она обеспечивает и по какому критерию хуже, чем SJF
Round Robin (RR) – алгоритм с квантованием времени, где каждый процесс получает фиксированный квант CPU.

Оптимальность:

✅ Справедливость – все процессы получают CPU, нет голодания.

✅ Хорошая реакция для интерактивных задач.

Недостатки по сравнению с SJF (Shortest Job First):

❌ Хуже среднее время ожидания, т.к. SJF минимизирует его.

❌ Производительность ниже для CPU-связанных задач из-за переключений.

24. Задача управления памятью. Входная очередь заданий
Управление памятью – распределение оперативной памяти между процессами, обеспечение защиты и эффективного использования.

Основные задачи:

Выделение и освобождение памяти.

Защита памяти процессов.

Виртуализация (если используется).

Откачка/подкачка (swapping/paging).

Входная очередь заданий – список процессов, готовых к загрузке в память для выполнения. ОС выбирает, какие процессы загружать, исходя из доступности памяти.

25. Связывание адресов и на каких этапах обработки программы оно может выполняться
Связывание адресов – процесс привязки символических адресов (переменных, функций) к физическим/логическим адресам.

Этапы:

Компиляция – символьные имена → относительные адреса.

Линковка – объединение модулей, формирование исполняемого файла.

Загрузка – преобразование относительных адресов в физические (если нет динамической загрузки).

Выполнение – динамическое связывание (например, через таблицы страниц).

26. Этапы обработки программы от исходного кода к двоичному образу в памяти
Препроцессинг – обработка директив (#include, #define).

Компиляция – перевод в ассемблерный код.

Ассемблирование – преобразование в объектный код.

Линковка – объединение объектных файлов в исполняемый.

Загрузка – размещение в памяти (статически или динамически).

Выполнение – загрузка в ОЗУ, выделение ресурсов.

27. Адресация с использованием регистра перемещения
Регистр перемещения (Relocation Register) – аппаратный регистр, хранящий базовый адрес процесса в памяти.

Принцип работы:

Логический адрес + значение регистра → физический адрес.

Используется в схеме перемещения с границей (Base-Limit).

Пример:

Логический адрес = 0x100, база = 0x2000 → физический = 0x2100.

28. Оверлейная структура двухпросмотрового ассемблера
Оверлей (Overlay) – метод загрузки частей программы по мере необходимости (актуально при нехватке памяти).

Двухпросмотровый ассемблер:

Первый проход – сбор меток и их адресов.

Второй проход – генерация кода с подстановкой адресов.

Связь с оверлеями: ассемблер может генерировать код, учитывающий оверлейные структуры.

29. Откачка и подкачка. Файл откачки. Смежное распределение памяти
Откачка (Swapping Out) – выгрузка процесса из ОЗУ на диск.
Подкачка (Swapping In) – загрузка обратно.

Файл откачки (Swap File/Pagefile) – область на диске для временного хранения выгруженных данных.

Смежное распределение – память выделяется непрерывным блоком.

Проблема: фрагментация.

Решение: дефрагментация или использование страничной организации.

Схема работы:

ОС решает выгрузить процесс.

Данные сохраняются в swap-файл.

При необходимости – загружаются обратно (возможно, в другое место).

30. Схема адресации с аппаратной поддержкой регистров перемещения и границы
Базовая схема (Base-Limit):

Регистр базы (Base) – начальный адрес процесса.

Регистр границы (Limit) – максимальный допустимый адрес.

Принцип работы:

CPU генерирует логический адрес.

Проверка: логический адрес < Limit.

Если да: физический адрес = Base + логический адрес.

Если нет – ошибка (нарушение защиты).

Преимущества:

Защита памяти.

Динамическое перемещение процессов.

31. Схема адресации с аппаратной поддержкой регистров перемещения и границы
Принцип работы:

Используется базовый регистр (Base) и регистр границы (Limit).

Base хранит начальный физический адрес процесса.

Limit определяет максимально допустимый логический адрес.

Процесс трансляции адреса:

Генерация логического адреса (LA) процессом.

Проверка: LA ≤ Limit. Если нет → ошибка (segmentation fault).

Физический адрес (PA) = Base + LA.

Преимущества:

Защита памяти (процесс не может выйти за свои границы).

Поддержка динамического перемещения программ.

Недостатки:

Неэффективность при фрагментации.

Ограниченность в многозадачных системах.

32. Архитектура трансляции адресов при страничной организации
Страничная организация – память делится на фиксированные блоки (страницы), а физическая память – на кадры.

Трансляция адресов:

Виртуальный адрес (VA) делится на:

Номер страницы (P) – индекс в таблице страниц.

Смещение (D) – позиция внутри страницы.

Таблица страниц (Page Table) сопоставляет P → номер кадра.

Физический адрес (PA) = (номер кадра × размер страницы) + D.

Аппаратная поддержка (MMU, TLB):

MMU (Memory Management Unit) – выполняет трансляцию.

TLB (Translation Lookaside Buffer) – кэш для ускорения доступа к таблице страниц.

33. Таблицы страниц. Защита памяти
Таблица страниц – структура, хранящая соответствие виртуальных страниц физическим кадрам.

Элементы таблицы страниц:

Бит присутствия (P) – страница в ОЗУ или на диске.

Бит модификации (D, dirty) – изменялась ли страница.

Бит доступа (R/W/X) – права на чтение/запись/исполнение.

Бит защиты (U/S) – доступ только для ядра (Supervisor) или пользователя (User).

Защита памяти:

ОС запрещает доступ к чужим страницам.

Попытка записи в read-only страницу → исключение.

34. Структура таблицы страниц. Хешированные таблицы страниц
Обычная таблица страниц:

Линейный массив, индексируемый номером страницы.

Проблема: большой объем (например, 4 ГБ виртуальной памяти с 4 КБ страницами → 1 млн записей).

Многоуровневые таблицы:

Иерархическая структура (например, 2–3 уровня).

Экономия памяти (не хранятся пустые диапазоны).

Хешированные таблицы:

Используют хеш-функцию для отображения номера страницы в компактную структуру.

Эффективны для очень больших адресных пространств (64-битные системы).

35. Откачка и подкачка. Файл откачки. Разделяемые страницы
Откачка (Swapping Out) – выгрузка страниц на диск (в файл подкачки или раздел swap).
Подкачка (Swapping In) – загрузка страниц обратно в ОЗУ.

Разделяемые страницы:

Несколько процессов могут использовать одни и те же физические страницы (например, код библиотек).

В таблице страниц указывается один кадр для разных виртуальных адресов.

Защита: страницы помечаются как read-only или copy-on-write.

36. Принципы сегментной организации памяти. Использование разделяемых сегментов
Сегментная организация – память делится на логические единицы (сегменты: код, данные, стек).

Особенности:

Разный размер сегментов.

Каждый сегмент имеет базовый адрес и длину.

Разделяемые сегменты:

Например, общие библиотеки или данные.

В таблице сегментов разных процессов одна запись может ссылаться на один физический сегмент.

37. Схема адресации при сегментной организации памяти. Пример
Формат виртуального адреса:

Номер сегмента (S) – индекс в таблице сегментов.

Смещение (D) – позиция внутри сегмента.

Трансляция:

Из таблицы сегментов получаем Base и Limit.

Проверка: D ≤ Limit.

Физический адрес = Base + D.

Пример:

Сегмент кода: Base=0x4000, Limit=0x1000.

Виртуальный адрес (S=1, D=0x200) → PA = 0x4000 + 0x200 = 0x4200.

38. Понятие файла. Структура файла. Методы доступа к файлам
Файл – именованная совокупность данных на носителе.

Структура:

Последовательность байтов (UNIX).

Записи фиксированной/переменной длины (базы данных).

Методы доступа:

Последовательный – чтение/запись линейно (ленточные накопители).

Прямой (произвольный) – доступ по номеру блока (жёсткие диски).

Индексный – через структуру индексов (например, FAT, NTFS).

39. Сетевые топологии. Стратегии маршрутизации
Топологии:

Звезда – все узлы подключены к центру (хабу).

Кольцо – данные передаются по кругу.

Шина – общий канал связи.

Сетка (Mesh) – каждый узел соединен с несколькими.

Стратегии маршрутизации:

Статическая – пути заданы вручную.

Динамическая:

Distance Vector (RIP) – маршрутизаторы обмениваются таблицами.

Link State (OSPF) – каждый строит карту сети.

40. Уровни сетевых протоколов (ISO). Структура сообщения. Уровни TCP/IP
Модель ISO/OSI (7 уровней):

Физический – биты, кабели.

Канальный – фреймы (Ethernet).

Сетевой – пакеты (IP).

Транспортный – сегменты (TCP/UDP).

Сеансовый – управление соединением.

Представления – кодирование данных.

Прикладной – HTTP, FTP.

TCP/IP (4 уровня):

Сетевой интерфейс (Ethernet).

Интернет (IP).

Транспортный (TCP/UDP).

Прикладной (HTTP, DNS).

Структура сообщения:

Заголовки каждого уровня добавляются к данным (инкапсуляция).

Пример: [Ethernet][IP][TCP][HTTP-данные].
