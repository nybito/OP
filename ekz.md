# Ответы на экзаменационные вопросы по Python

## 1. Язык Python - общая характеристика, преимущества и недостатки, краткая история. PEP's

### Общая характеристика
Python - это высокоуровневый, интерпретируемый, объектно-ориентированный язык программирования общего назначения с динамической типизацией и автоматическим управлением памятью. Он поддерживает несколько парадигм программирования: императивное, объектно-ориентированное, функциональное и аспектно-ориентированное.

### Преимущества Python:
1. **Простота и читаемость**: Чистый синтаксис, близкий к псевдокоду, с обязательными отступами.
2. **Кроссплатформенность**: Работает на Windows, Linux, macOS и других ОС.
3. **Большая стандартная библиотека**: Включает модули для работы с ОС, сетями, XML, JSON и др.
4. **Динамическая типизация**: Не нужно объявлять типы переменных.
5. **Автоматическое управление памятью**: Сборщик мусора освобождает память автоматически.
6. **Поддержка множества парадигм**: ООП, функциональное, процедурное программирование.
7. **Большое сообщество и экосистема**: Множество фреймворков (Django, Flask), библиотек (NumPy, Pandas).
8. **Интеграция**: Легко интегрируется с C/C++, Java, .NET.

### Недостатки Python:
1. **Скорость выполнения**: Медленнее компилируемых языков (C, Java).
2. **Потребление памяти**: Выше, чем у низкоуровневых языков.
3. **Глобальная блокировка интерпретатора (GIL)**: Ограничивает параллельное выполнение потоков.
4. **Динамическая типизация**: Может приводить к ошибкам в runtime.
5. **Не подходит для системного программирования**: Низкоуровневые операции затруднены.

### Краткая история:
- 1989: Гвидо ван Россум начал разработку Python в Нидерландах.
- 1991: Первый публичный релиз Python 0.9.0.
- 2000: Python 2.0 с сборщиком мусора и поддержкой Unicode.
- 2008: Python 3.0 (несовместим с Python 2).
- 2020: Окончание поддержки Python 2.7.

### PEP (Python Enhancement Proposals)
PEP - это документы, описывающие новые возможности Python или процессы. Важные PEP:
- **PEP 8**: Стиль кодирования (отступы, именование и т.д.)
- **PEP 20**: The Zen of Python (философия языка)
- **PEP 484**: Аннотации типов
- **PEP 572**: Оператор присваивания := (моржовый оператор)
- **PEP 3107**: Аннотации функций

## 2. Работа интерпретатора. PVM. Байт-код. Выполнение и способы запуска кода и программ

### Работа интерпретатора Python
1. **Лексический анализ**: Разбиение кода на токены (ключевые слова, идентификаторы, операторы).
2. **Синтаксический анализ**: Построение абстрактного синтаксического дерева (AST).
3. **Генерация байт-кода**: Трансляция AST в байт-код (файлы .pyc).
4. **Выполнение байт-кода**: Виртуальная машина Python (PVM) исполняет байт-код.

### PVM (Python Virtual Machine)
PVM - это интерпретатор байт-кода Python. Он:
- Читает и выполняет байт-код
- Управляет памятью (выделение, сборка мусора)
- Обрабатывает исключения
- Обеспечивает взаимодействие с ОС

### Байт-код
Байт-код - это низкоуровневое представление Python-кода (не машинный код). Характеристики:
- Кроссплатформенный
- Оптимизирован для выполнения PVM
- Хранится в файлах .pyc (кешируется для ускорения последующих запусков)
- Можно просмотреть с помощью модуля `dis`

Пример просмотра байт-кода:
```python
import dis
dis.dis('print("Hello")')
```

### Способы запуска кода
1. **Интерактивный режим**: Запуск интерпретатора (`python` или `python3` в терминале).
2. **Запуск скрипта**: `python script.py`
3. **Импорт модуля**: `import module`
4. **Jupyter Notebook**: Интерактивные блокноты
5. **Исполняемые файлы**: С помощью pyinstaller или cx_Freeze
6. **Встроенный в приложения**: Внедрение Python в другие приложения (Blender, Maya)

## 3. Основные примитивные типы данных. Реализация операций над ними

### Числовые типы
1. **int**: Целые числа произвольной точности
   ```python
   a = 42
   b = 10**100  # Очень большое число
   ```
2. **float**: Числа с плавающей точкой (64-bit)
   ```python
   pi = 3.14159
   ```
3. **complex**: Комплексные числа
   ```python
   c = 3 + 4j
   ```

### Логический тип
- **bool**: True или False
  ```python
  flag = True
  ```

### Последовательности
1. **str**: Строки Unicode
   ```python
   s = "Hello"
   ```
2. **bytes**: Байтовые строки
   ```python
   b = b'data'
   ```
3. **bytearray**: Изменяемые байтовые строки
   ```python
   ba = bytearray(b'data')
   ```

### NoneType
- **None**: Отсутствие значения
  ```python
  x = None
  ```

### Операции над примитивными типами
1. **Арифметические**: `+`, `-`, `*`, `/`, `//`, `%`, `**`
2. **Сравнение**: `==`, `!=`, `<`, `>`, `<=`, `>=`
3. **Логические**: `and`, `or`, `not`
4. **Побитовые**: `&`, `|`, `^`, `~`, `<<`, `>>`
5. **Принадлежность**: `in`, `not in`
6. **Тождественность**: `is`, `is not`

Особенности:
- Целые числа в Python имеют произвольную точность
- Деление `/` всегда возвращает float, `//` - целочисленное
- Строки неизменяемы, операции создают новые строки
- None - синглтон, проверяется через `is`

## 4. Последовательности. Операции над последовательностями

### Типы последовательностей
1. **Неизменяемые**:
   - str (строки)
   - tuple (кортежи)
   - bytes (байтовые строки)
2. **Изменяемые**:
   - list (списки)
   - bytearray

### Основные операции
1. **Доступ по индексу**: `seq[index]` (отрицательные индексы с конца)
2. **Срезы**: `seq[start:stop:step]`
3. **Конкатенация**: `seq1 + seq2`
4. **Повторение**: `seq * n`
5. **Проверка вхождения**: `x in seq`, `x not in seq`
6. **Длина**: `len(seq)`
7. **Минимум/максимум**: `min(seq)`, `max(seq)`
8. **Индекс элемента**: `seq.index(x)`
9. **Подсчет элементов**: `seq.count(x)`

### Методы изменяемых последовательностей
1. **Добавление**:
   - `append(x)` - в конец
   - `extend(iterable)` - расширение
   - `insert(i, x)` - в позицию i
2. **Удаление**:
   - `remove(x)` - первое вхождение x
   - `pop([i])` - удалить и вернуть элемент
   - `clear()` - очистить
3. **Изменение**:
   - `reverse()` - обратный порядок
   - `sort(key=None, reverse=False)` - сортировка

### Особенности
- Кортежи с одним элементом: `(x,)` (запятая обязательна)
- Срезы создают новые объекты для неизменяемых последовательностей
- Генераторы последовательностей: `range()`, `enumerate()`, `zip()`
- Последовательности поддерживают итерацию

Примеры:
```python
# Создание последовательностей
lst = [1, 2, 3]
tpl = (1, 2, 3)
s = "abc"

# Операции
lst[0] = 10  # Изменяемый
# tpl[0] = 10  # Ошибка - неизменяемый
new_s = s[:2] + 'x' + s[3:]  # Создание новой строки

# Генераторы
r = range(5)  # 0,1,2,3,4
```

## 5. Операция связывания и динамическая типизация

### Операция связывания
В Python переменные - это имена, связанные с объектами в памяти. Присваивание (`=`) создает связь между именем и объектом.

Особенности:
- Не требуется объявление типа
- Одно имя может связываться с разными объектами в разное время
- Несколько имен могут ссылаться на один объект

Пример:
```python
x = 10  # x ссылается на целое число 10
x = "text"  # Теперь x ссылается на строку
y = x  # y ссылается на тот же объект, что и x
```

### Динамическая типизация
Python использует динамическую типизацию:
- Тип проверяется во время выполнения
- Переменная может менять тип
- Объекты имеют тип, но имена - нет

Пример:
```python
x = 10  # int
x = "hello"  # str
x = [1, 2, 3]  # list
```

### Особенности
1. **Ссылочная модель**: Переменные хранят ссылки на объекты
2. **Поведение при присваивании**:
   - Примитивы (int, float, str): создается новый объект или используется существующий
   - Составные объекты (list, dict): копируется только ссылка
3. **Проверка тождественности**: `is` проверяет, ссылаются ли имена на один объект
4. **Проверка равенства**: `==` проверяет равенство значений

Пример:
```python
a = [1, 2, 3]
b = a  # b ссылается на тот же список
b.append(4)
print(a)  # [1, 2, 3, 4] - изменился исходный список

c = [1, 2, 3, 4]
print(a == c)  # True - значения равны
print(a is c)  # False - разные объекты
```

## 6. Условный оператор. Логические операции и логические сравнения

### Условный оператор if
Синтаксис:
```python
if условие1:
    блок1
elif условие2:
    блок2
else:
    блок3
```

Особенности:
- Отступы определяют блоки кода
- `elif` и `else` не обязательны
- Условие может быть любым выражением, приводящимся к bool

Пример:
```python
x = 10
if x > 0:
    print("Positive")
elif x < 0:
    print("Negative")
else:
    print("Zero")
```

### Логические операции
1. **and**: Логическое И (возвращает последний истинный или первый ложный операнд)
2. **or**: Логическое ИЛИ (возвращает первый истинный или последний ложный операнд)
3. **not**: Логическое НЕ (возвращает bool)

Особенности:
- Ленивое вычисление (short-circuit evaluation)
- Возвращают значение операнда, а не обязательно bool

Пример:
```python
x = 5
print(x > 0 and x < 10)  # True
print(not x)  # False
print(0 or "default")  # "default"
```

### Логические сравнения
Операторы сравнения: `==`, `!=`, `<`, `>`, `<=`, `>=`, `is`, `is not`, `in`, `not in`

Особенности:
- Можно объединять в цепочки: `0 < x < 10`
- `is` проверяет идентичность объектов (тот же объект в памяти)
- `==` проверяет равенство значений
- Для пользовательских классов можно переопределять `__eq__`, `__lt__` и др.

Пример:
```python
a = [1, 2, 3]
b = a
c = [1, 2, 3]

print(a == b)  # True
print(a == c)  # True
print(a is b)  # True
print(a is c)  # False
```

### Тернарный оператор
Синтаксис: `значение_if_истина if условие else значение_if_ложь`

Пример:
```python
x = 10
message = "Positive" if x > 0 else "Non-positive"
```

## 7. Циклы

### Цикл while
Синтаксис:
```python
while условие:
    блок
else:  # необязательно
    блок (выполняется, если цикл завершился нормально, без break)
```

Пример:
```python
i = 0
while i < 5:
    print(i)
    i += 1
else:
    print("Loop completed")
```

### Цикл for
Синтаксис:
```python
for элемент in итерируемый_объект:
    блок
else:  # необязательно
    блок (выполняется, если цикл завершился нормально, без break)
```

Пример:
```python
for i in range(5):
    print(i)
```

### Управление циклом
1. **break**: Выход из цикла
2. **continue**: Переход к следующей итерации
3. **pass**: Пустая операция (заполнитель)

### Итерируемые объекты
- Последовательности (list, tuple, str, bytes)
- Словари (dict)
- Множества (set)
- Файлы
- Генераторы (range, enumerate, zip и др.)
- Любые объекты с методами `__iter__()` или `__getitem__()`

### Функция range()
Создает последовательность чисел:
- `range(stop)`
- `range(start, stop)`
- `range(start, stop, step)`

Пример:
```python
for i in range(2, 10, 2):
    print(i)  # 2, 4, 6, 8
```

### enumerate()
Возвращает пары (индекс, элемент):

```python
for i, value in enumerate(['a', 'b', 'c']):
    print(i, value)
```

### zip()
Объединяет несколько итерируемых объектов:

```python
names = ['Alice', 'Bob']
ages = [25, 30]
for name, age in zip(names, ages):
    print(name, age)
```

## 8. Итерации и включения. Протокол итерации

### Итерации
Итерация - процесс последовательного обращения к элементам коллекции.

### Протокол итерации
Состоит из двух методов:
1. `__iter__()`: Возвращает объект-итератор
2. `__next__()`: Возвращает следующий элемент или вызывает StopIteration

### Итератор vs Итерируемый объект
- **Итерируемый объект**: Имеет `__iter__()` (list, tuple, dict и др.)
- **Итератор**: Имеет `__next__()` (обычно сам себя возвращает из `__iter__()`)

Пример реализации:
```python
class Counter:
    def __init__(self, low, high):
        self.current = low
        self.high = high

    def __iter__(self):
        return self

    def __next__(self):
        if self.current > self.high:
            raise StopIteration
        else:
            self.current += 1
            return self.current - 1

for num in Counter(3, 8):
    print(num)
```

### Генераторы
Специальный тип итераторов, создаются с помощью:
1. **Функций-генераторов** (с yield)
   ```python
   def countdown(n):
       while n > 0:
           yield n
           n -= 1
   ```
2. **Генераторных выражений**
   ```python
   squares = (x*x for x in range(10))
   ```

### Включения (Comprehensions)
Синтаксис для создания коллекций:
1. **Списки**:
   ```python
   [x**2 for x in range(10) if x % 2 == 0]
   ```
2. **Множества**:
   ```python
   {x % 5 for x in range(100)}
   ```
3. **Словари**:
   ```python
   {x: x**2 for x in range(5)}
   ```

Особенности:
- Более читаемы и эффективны, чем циклы
- Могут быть вложенными
- Могут включать условия

Пример:
```python
matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
flat = [num for row in matrix for num in row if num % 2 == 0]
```

## 9. Функции. Чистота функций. Побочные эффекты. Области видимости. LEGB. global и nonlocal

### Функции
Функция - это блок кода, который можно вызывать по имени.

Синтаксис:
```python
def имя(параметры):
    """docstring"""
    тело
    return результат  # необязательно
```

### Чистые функции
Чистая функция:
- Зависит только от своих аргументов
- Не имеет побочных эффектов
- Всегда возвращает одинаковый результат для одинаковых аргументов

Пример:
```python
def pure_add(a, b):
    return a + b
```

### Побочные эффекты
Побочный эффект - изменение состояния вне функции:
- Изменение глобальных переменных
- Изменение изменяемых аргументов
- Ввод/вывод
- Вызов других функций с побочными эффектами

Пример:
```python
def impure_add(a, b):
    print("Adding")  # Побочный эффект (вывод)
    global counter
    counter += 1     # Побочный эффект (изменение глобальной переменной)
    return a + b
```

### Области видимости (LEGB)
Правило поиска имен в Python (от локальной к глобальной):
1. **L (Local)**: Внутри функции
2. **E (Enclosing)**: В объемлющих функциях (для вложенных функций)
3. **G (Global)**: На уровне модуля
4. **B (Built-in)**: Встроенные имена (print, len и др.)

### global и nonlocal
- **global**: Позволяет изменять глобальные переменные из функции
  ```python
  x = 0
  def increment():
      global x
      x += 1
  ```
- **nonlocal**: Позволяет изменять переменные из объемлющей (но не глобальной) области
  ```python
  def outer():
      x = 0
      def inner():
          nonlocal x
          x += 1
      inner()
      print(x)  # 1
  ```

### Замыкания
Функция, запоминающая значения из объемлющей области:
```python
def make_adder(n):
    def adder(x):
        return x + n
    return adder

add5 = make_adder(5)
print(add5(3))  # 8
```

### Декораторы
Функции, изменяющие поведение других функций:
```python
def logger(func):
    def wrapper(*args, **kwargs):
        print(f"Calling {func.__name__}")
        return func(*args, **kwargs)
    return wrapper

@logger
def add(a, b):
    return a + b
```

## 10. Передача аргументов. Режимы сопоставления аргументов

### Способы передачи аргументов
1. **Позиционные аргументы**: Сопоставляются по порядку
   ```python
   def func(a, b, c):
       pass
   func(1, 2, 3)
   ```
2. **Именованные аргументы**: Сопоставляются по имени
   ```python
   func(b=2, a=1, c=3)
   ```
3. **Смешанный вариант**: Сначала позиционные, потом именованные
   ```python
   func(1, c=3, b=2)
   ```

### Виды параметров
1. **Обязательные параметры**: Должны быть переданы
   ```python
   def func(a, b):
       pass
   ```
2. **Параметры по умолчанию**:
   ```python
   def func(a, b=10):
       pass
   ```
3. **Произвольное число позиционных аргументов** (`*args`):
   ```python
   def func(*args):
       pass
   ```
4. **Произвольное число именованных аргументов** (`**kwargs`):
   ```python
   def func(**kwargs):
       pass
   ```

### Распаковка аргументов
- `*iterable` распаковывает последовательность в позиционные аргументы
- `**dict` распаковывает словарь в именованные аргументы

Пример:
```python
def func(a, b, c):
    print(a, b, c)

args = (1, 2, 3)
func(*args)  # Эквивалентно func(1, 2, 3)

kwargs = {'a': 1, 'b': 2, 'c': 3}
func(**kwargs)  # Эквивалентно func(a=1, b=2, c=3)
```

### Правила сопоставления аргументов
Порядок параметров в определении функции:
1. Обычные параметры (a, b)
2. Параметры со значениями по умолчанию (c=10)
3. `*args` для дополнительных позиционных аргументов
4. `**kwargs` для дополнительных именованных аргументов

Пример:
```python
def func(a, b=2, *args, **kwargs):
    print(a, b, args, kwargs)

func(1)  # 1 2 () {}
func(1, 3)  # 1 3 () {}
func(1, 3, 4, 5, x=10)  # 1 3 (4, 5) {'x': 10}
```

### Особенности параметров по умолчанию
Значения по умолчанию вычисляются один раз при определении функции (для изменяемых объектов это может привести к неожиданностям):

```python
def func(lst=[]):  # Не рекомендуется!
    lst.append(1)
    print(lst)

func()  # [1]
func()  # [1, 1]  # То же самое list!
```

Рекомендуемый способ:
```python
def func(lst=None):
    if lst is None:
        lst = []
    lst.append(1)
    print(lst)
```

### Аннотации типов (PEP 484)
Можно указывать ожидаемые типы параметров и возвращаемого значения:
```python
def greet(name: str, age: int = 18) -> str:
    return f"{name} is {age} years old"
```

## 11. Функции. Документирование и тестирование функций

**Функции** в Python - это блоки кода, которые выполняют определенную задачу и могут быть вызваны многократно. 

**Документирование функций**:
- Используются docstrings (строки документации) в тройных кавычках
- Лучшие практики:
  - Первая строка - краткое описание
  - Затем более подробное описание
  - Примеры использования (можно с doctest)
  - Описание параметров и возвращаемого значения

Пример:
```python
def add(a, b):
    """
    Складывает два числа.
    
    Args:
        a (int/float): Первое число
        b (int/float): Второе число
        
    Returns:
        int/float: Сумма a и b
        
    Examples:
        >>> add(2, 3)
        5
        >>> add(2.5, 3.1)
        5.6
    """
    return a + b
```

**Тестирование функций**:
1. Doctest - тесты прямо в docstring
2. Unittest - встроенный модуль для unit-тестов
3. Pytest - популярный фреймворк для тестирования

Пример unittest:
```python
import unittest

class TestAdd(unittest.TestCase):
    def test_add_integers(self):
        self.assertEqual(add(2, 3), 5)
    
    def test_add_floats(self):
        self.assertAlmostEqual(add(2.5, 3.1), 5.6)

if __name__ == '__main__':
    unittest.main()
```

## 12. Функции первого класса. Функции в качестве аргументов. Возвращаемые функции. Вложенные функции.

**Функции первого класса** - это когда функции могут:
1. Присваиваться переменным
2. Передаваться как аргументы другим функциям
3. Возвращаться из других функций
4. Храниться в структурах данных

**Функции как аргументы**:
```python
def apply(func, x, y):
    return func(x, y)

def multiply(a, b):
    return a * b

result = apply(multiply, 3, 4)  # 12
```

**Возвращаемые функции**:
```python
def make_adder(n):
    def adder(x):
        return x + n
    return adder

add5 = make_adder(5)
print(add5(3))  # 8
```

**Вложенные функции**:
- Функции, определенные внутри других функций
- Имеют доступ к переменным объемлющей функции (замыкания)
- Полезны для:
  - Инкапсуляции логики
  - Создания фабрик функций
  - Реализации декораторов

Пример:
```python
def outer():
    x = 10
    def inner():
        nonlocal x
        x += 1
        return x
    return inner

f = outer()
print(f())  # 11
print(f())  # 12
```

## 13. Функции первого класса. Каррирование и декаррирование.

**Каррирование** - преобразование функции от многих аргументов в последовательность функций, каждая из которых принимает один аргумент.

Пример каррирования:
```python
def curry(f):
    def g(x):
        def h(y):
            return f(x, y)
        return h
    return g

def add(a, b):
    return a + b

curried_add = curry(add)
add5 = curried_add(5)
print(add5(3))  # 8
```

**Декаррирование** - обратное преобразование, превращение последовательности функций в одну функцию от многих аргументов.

Пример декаррирования:
```python
def uncurry(f):
    def g(x, y):
        return f(x)(y)
    return g

uncurried_add = uncurry(curry(add))
print(uncurried_add(5, 3))  # 8
```

Практическое применение:
- Каррирование полезно для создания специализированных функций
- Позволяет использовать частичное применение аргументов
- Используется в функциональном программировании

## 14. Анонимные функции. map, reduce, filter.

**Анонимные функции (лямбда-функции)**:
- Создаются с помощью ключевого слова `lambda`
- Могут принимать любое количество аргументов, но содержат только одно выражение
- Не имеют имени (но могут быть присвоены переменной)

Пример:
```python
square = lambda x: x * x
print(square(5))  # 25
```

**map(func, iterable)** - применяет функцию к каждому элементу итерируемого объекта:
```python
numbers = [1, 2, 3, 4]
squared = list(map(lambda x: x**2, numbers))  # [1, 4, 9, 16]
```

**filter(func, iterable)** - фильтрует элементы, оставляя только те, для которых функция возвращает True:
```python
even = list(filter(lambda x: x % 2 == 0, numbers))  # [2, 4]
```

**reduce(func, iterable[, initial])** (из модуля functools) - последовательно применяет функцию к элементам, сводя их к одному значению:
```python
from functools import reduce
product = reduce(lambda x, y: x * y, numbers)  # 24 (1*2*3*4)
```

## 15. Декораторы.

**Декораторы** - это функции, которые изменяют поведение других функций.

Базовый пример:
```python
def my_decorator(func):
    def wrapper():
        print("До вызова функции")
        func()
        print("После вызова функции")
    return wrapper

@my_decorator
def say_hello():
    print("Привет!")

say_hello()
# Вывод:
# До вызова функции
# Привет!
# После вызова функции
```

Декораторы с аргументами:
```python
def repeat(num_times):
    def decorator(func):
        def wrapper(*args, **kwargs):
            for _ in range(num_times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(num_times=3)
def greet(name):
    print(f"Привет, {name}")

greet("Алиса")
```

Встроенные декораторы:
- `@staticmethod` - статический метод класса
- `@classmethod` - метод класса
- `@property` - геттер для свойства

## 16. Рекурсивные функции. Структура рекурсивной функции. Взаимная рекурсия. Древесная рекурсия. Повышение производительности рекурсии.

**Рекурсивные функции** - функции, вызывающие сами себя.

Структура рекурсивной функции:
1. Базовый случай (когда рекурсия останавливается)
2. Рекурсивный случай (вызов функции с измененными параметрами)

Пример (факториал):
```python
def factorial(n):
    if n == 1:  # базовый случай
        return 1
    else:       # рекурсивный случай
        return n * factorial(n-1)
```

**Взаимная рекурсия** - когда две или более функций вызывают друг друга:
```python
def is_even(n):
    if n == 0:
        return True
    else:
        return is_odd(n-1)

def is_odd(n):
    if n == 0:
        return False
    else:
        return is_even(n-1)
```

**Древесная рекурсия** - когда функция делает более одного рекурсивного вызова (например, числа Фибоначчи):
```python
def fib(n):
    if n <= 1:
        return n
    else:
        return fib(n-1) + fib(n-2)  # два рекурсивных вызова
```

**Повышение производительности**:
1. Мемоизация (кеширование результатов)
2. Использование итеративного подхода вместо рекурсивного
3. Оптимизация хвостовой рекурсии (хотя Python не оптимизирует хвостовую рекурсию по умолчанию)

Пример с мемоизацией:
```python
from functools import lru_cache

@lru_cache(maxsize=None)
def fib(n):
    if n <= 1:
        return n
    else:
        return fib(n-1) + fib(n-2)
```

## 17. Генераторы и включения. Генераторные функции. Генераторные выражения.

**Генераторы** - специальные итераторы, которые генерируют значения "на лету".

**Генераторные функции**:
- Содержат ключевое слово `yield`
- При вызове возвращают генератор, а не выполняются сразу
- Сохраняют состояние между вызовами

Пример:
```python
def count_up_to(max):
    count = 1
    while count <= max:
        yield count
        count += 1

counter = count_up_to(5)
for num in counter:
    print(num)  # 1, 2, 3, 4, 5
```

**Генераторные выражения**:
- Похожи на list comprehensions, но возвращают генератор
- Используют круглые скобки вместо квадратных

Пример:
```python
squares = (x*x for x in range(5))
for num in squares:
    print(num)  # 0, 1, 4, 9, 16
```

Преимущества генераторов:
- Экономия памяти (не хранят все значения в памяти)
- Ленивые вычисления (генерируют значения по требованию)
- Позволяют работать с бесконечными последовательностями

## 18. Модули и пакеты. Архитектура программы.

**Модуль** - файл с расширением .py, содержащий Python-код.

**Пакет** - каталог, содержащий модули и файл `__init__.py`.

Архитектура программы:
1. Разделение кода на логические модули
2. Группировка связанных модулей в пакеты
3. Иерархическая структура:
   - Корневой каталог проекта
   - Подкаталоги для разных компонентов
   - Файл `__init__.py` в каждом пакете
4. Рекомендуемая структура:
   ```
   project/
   ├── main.py
   ├── package1/
   │   ├── __init__.py
   │   ├── module1.py
   │   └── module2.py
   └── package2/
       ├── __init__.py
       └── module3.py
   ```

Принципы хорошей архитектуры:
- Высокая связность (cohesion)
- Низкая связанность (coupling)
- Принцип единственной ответственности
- Разделение интерфейса и реализации

## 19. Импортирование. Способы и их работа.

Способы импорта:
1. Импорт всего модуля:
   ```python
   import math
   print(math.sqrt(16))
   ```

2. Импорт конкретных имен:
   ```python
   from math import sqrt, pi
   print(sqrt(16))
   ```

3. Импорт с псевдонимом:
   ```python
   import numpy as np
   from math import sqrt as square_root
   ```

4. Импорт всего содержимого модуля (не рекомендуется):
   ```python
   from math import *
   ```

Механизм работы импорта:
1. Поиск модуля в sys.modules (кеш)
2. Поиск в списке sys.path (включает текущий каталог, PYTHONPATH, стандартные пути)
3. Загрузка и выполнение модуля
4. Создание объекта модуля и добавление в sys.modules
5. Привязка имени в текущем пространстве имен

## 20. Пакеты модулей. Абсолютное и относительное импортирование.

**Пакеты модулей** - способ организации пространства имен с помощью каталогов.

Структура пакета:
```
my_package/
├── __init__.py
├── module1.py
└── subpackage/
    ├── __init__.py
    └── module2.py
```

**Абсолютный импорт** - полный путь от корня проекта:
```python
from my_package.module1 import some_function
from my_package.subpackage.module2 import another_function
```

**Относительный импорт** - путь относительно текущего модуля (использует точки):
- `.` - текущий пакет
- `..` - родительский пакет
- `...` - пакет уровнем выше и т.д.

Пример:
```python
# В модуле my_package/subpackage/module2.py
from ..module1 import some_function  # импорт из родительского пакета
```

Правила импорта:
1. В Python 3 все импорты в пакетах должны быть абсолютными или относительными
2. Относительный импорт работает только внутри пакетов
3. `__init__.py` может содержать код инициализации пакета
4. `__all__` в `__init__.py` определяет, что импортируется при `from package import *`

Рекомендации:
- Предпочитать абсолютные импорты для ясности
- Использовать относительные импорты для внутрипакетных ссылок
- Избегать циклических импортов


## 21. Концепции ООП. Классы, объекты, экземпляры, атрибуты, поля, методы.

**Объектно-ориентированное программирование (ООП)** - это парадигма программирования, основанная на концепции объектов, которые могут содержать данные (атрибуты) и код (методы). Основные концепции:

1. **Класс** - это шаблон или чертеж для создания объектов. Определяет структуру и поведение объектов.
   ```python
   class Person:
       pass
   ```

2. **Объект (экземпляр)** - конкретная реализация класса. Каждый объект имеет собственное состояние (значения атрибутов).
   ```python
   person1 = Person()
   ```

3. **Атрибуты** - переменные, принадлежащие объекту или классу. Бывают:
   - **Поля (атрибуты данных)** - переменные, хранящие состояние объекта.
   - **Методы** - функции, принадлежащие объекту или классу, определяющие его поведение.

   ```python
   class Person:
       species = 'Homo sapiens'  # атрибут класса (поле)
       
       def __init__(self, name):
           self.name = name  # атрибут экземпляра (поле)
       
       def speak(self):  # метод экземпляра
           print(f"My name is {self.name}")
   ```

## 22. Оператор class и его работа. Классы и экземпляры.

Оператор `class` используется для создания классов:

```python
class MyClass:
    """Документация класса"""
    class_attribute = 42
    
    def __init__(self, value):
        self.instance_attribute = value
    
    def method(self):
        return self.instance_attribute
```

**Как работает оператор class:**
1. Выполняется блок кода внутри класса, создавая namespace (пространство имен) класса.
2. Создается объект класса (не путать с экземпляром!).
3. Присваивается имя класса созданному объекту класса.

**Создание экземпляра:**
```python
obj = MyClass(10)  # создание экземпляра
```

**Отличия классов и экземпляров:**
- Класс - это фабрика объектов, описывающая их структуру.
- Экземпляр - конкретный объект, созданный по шаблону класса.
- Атрибуты класса общие для всех экземпляров.
- Атрибуты экземпляра уникальны для каждого объекта.

## 23. Наследование. MRO.

**Наследование** - механизм, позволяющий создавать новый класс на основе существующего.

```python
class Parent:
    def parent_method(self):
        print("Parent method")

class Child(Parent):
    def child_method(self):
        print("Child method")
```

**MRO (Method Resolution Order)** - порядок разрешения методов, определяющий, в каком порядке Python будет искать метод в иерархии наследования.

```python
class A:
    pass

class B(A):
    pass

class C(A):
    pass

class D(B, C):
    pass

print(D.mro())  # [<class '__main__.D'>, <class '__main__.B'>, <class '__main__.C'>, <class '__main__.A'>, <class 'object'>]
```

MRO использует алгоритм C3, который гарантирует:
1. Сохранение порядка в иерархии наследования
2. Монотонность (не изменяет порядок предков)
3. Локальный порядок предпочтения

## 24. Создание экземпляров. Конструкторы, деструкторы, инициализаторы.

1. **Инициализатор (`__init__`)** - метод, вызываемый при создании экземпляра для инициализации атрибутов.
   ```python
   class MyClass:
       def __init__(self, value):
           self.value = value
   ```

2. **Конструктор (`__new__`)** - метод, который фактически создает экземпляр (вызывается перед `__init__`).
   ```python
   class MyClass:
       def __new__(cls, *args, **kwargs):
           instance = super().__new__(cls)
           return instance
   ```

3. **Деструктор (`__del__`)** - метод, вызываемый перед удалением объекта сборщиком мусора.
   ```python
   class MyClass:
       def __del__(self):
           print("Объект удаляется")
   ```

**Процесс создания экземпляра:**
1. Вызывается `__new__` для создания экземпляра
2. Вызывается `__init__` для инициализации экземпляра
3. При удалении объекта вызывается `__del__` (если определен)

## 25. Перегрузка операций.

Перегрузка операций - определение специальных методов для изменения поведения операторов.

```python
class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    def __add__(self, other):  # перегрузка +
        return Vector(self.x + other.x, self.y + other.y)
    
    def __str__(self):  # перегрузка str()
        return f"Vector({self.x}, {self.y})"
```

Основные специальные методы:
- Арифметические операции: `__add__`, `__sub__`, `__mul__`, и т.д.
- Сравнения: `__eq__`, `__lt__`, `__gt__`, и т.д.
- Представления: `__str__`, `__repr__`
- Доступ к элементам: `__getitem__`, `__setitem__`
- Вызов объекта: `__call__`

## 26. Методики связывания классов. Абстрактные суперклассы.

**Методики связывания классов:**
1. Наследование
2. Композиция (включение объектов других классов как атрибутов)
3. Агрегация (более слабая форма композиции)
4. Делегирование (передача части ответственности другому классу)

**Абстрактные суперклассы** - классы, которые не предназначены для создания экземпляров, а только для наследования.

```python
from abc import ABC, abstractmethod

class AbstractAnimal(ABC):
    @abstractmethod
    def make_sound(self):
        pass

class Dog(AbstractAnimal):
    def make_sound(self):
        return "Woof!"
```

## 27. Обработка исключений. Оператор try.

**Исключения** - механизм обработки ошибок в Python.

```python
try:
    # код, который может вызвать исключение
    result = 10 / 0
except ZeroDivisionError:
    # обработка конкретного исключения
    print("Деление на ноль!")
except (TypeError, ValueError) as e:
    # обработка нескольких исключений
    print(f"Ошибка типа или значения: {e}")
except Exception:
    # обработка всех исключений
    print("Неизвестная ошибка")
else:
    # выполняется, если исключений не было
    print("Успешно выполнено")
finally:
    # выполняется всегда
    print("Блок finally")
```

## 28. Иерархия исключений. Создание собственных исключений.

**Иерархия исключений:**
```
BaseException
 ├── SystemExit
 ├── KeyboardInterrupt
 ├── GeneratorExit
 └── Exception
      ├── ArithmeticError
      │    ├── FloatingPointError
      │    ├── OverflowError
      │    └── ZeroDivisionError
      ├── AssertionError
      ├── AttributeError
      ├── ... и многие другие
```

**Создание собственных исключений:**
```python
class MyCustomError(Exception):
    """Мое пользовательское исключение"""
    def __init__(self, message, code):
        super().__init__(message)
        self.code = code

try:
    raise MyCustomError("Ошибка", 500)
except MyCustomError as e:
    print(f"Сообщение: {e}, Код: {e.code}")
```

## 29. Операторы raise и assert.

**raise** - используется для явного возбуждения исключения.
```python
if value < 0:
    raise ValueError("Значение не может быть отрицательным")
```

**assert** - проверка условия, если False - возбуждается AssertionError.
```python
assert x > 0, "x должен быть положительным"
# Эквивалентно:
if not x > 0:
    raise AssertionError("x должен быть положительным")
```

## 30. Диспетчеры контекстов. Протокол управления контекстами.

**Менеджер контекста** - объект, определяющий контекст выполнения блока кода.

**Протокол управления контекстом** требует реализации двух методов:
1. `__enter__` - выполняется при входе в контекст
2. `__exit__` - выполняется при выходе из контекста

```python
class MyContextManager:
    def __enter__(self):
        print("Вход в контекст")
        return self
    
    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Выход из контекста")
        if exc_type:
            print(f"Произошло исключение: {exc_val}")
        return True  # подавляет исключение

with MyContextManager() as cm:
    print("Внутри контекста")
    # raise Exception("Ошибка")  # будет обработана в __exit__
```

**Использование contextlib:**
```python
from contextlib import contextmanager

@contextmanager
def my_context():
    print("Вход")
    try:
        yield "значение"
    except Exception as e:
        print(f"Ошибка: {e}")
    finally:
        print("Выход")

with my_context() as value:
    print(f"Получено: {value}")
```
